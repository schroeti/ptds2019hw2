---
title: "HW 2"
author: "Rita Sefraoui Tahiri, Simon Fornerod, David Pitteloud, Leonard Philippossian, Alexandre Schroeter"
date: "08/10/2019"
output: html_document
---

## Problem 1: Fuzz Bizz
```{r}
i <- 1
df <- data.frame()
while (i<=1000)  {
  if ((i%%5==0) & (i%%3==0)) {
    df <- rbind(df,c("Fuzzbizz"))
  } else if (i%%5==0){
    df <- rbind(df,c("Bizz"))
  } else if (i%%3==0) {
    df <- rbind(df,c("Fuzz"))
  } else {
    df <- rbind(df,c(i))
  }
  i <- i+1
}
print(df)


```



## Problem 2: Map
```{r}
library(rworldmap)
library(rworldxtra)
library(ggmap)
library(tidyverse)
library(magrittr)
library(ptdspkg)
library(mapproj)
library(plotly)

cities <- tibble(
  name = c("zurich", "bern", "lausanne", "geneva", "basel"),
  language = c("german", "german", "french", "french", "german"),
  latitude = c(47.369019, 46.948002, 46.519630, 46.204391, 47.559608),
  longitude = c(8.538030, 7.448130, 6.632130, 6.143158, 7.580610)
)

get_volume("zurich", delay = 1)
get_volume("bern", delay = 1)
get_volume("lausanne", delay = 1)
get_volume("geneva", delay = 1)
get_volume("basel", delay = 1)
cities <- cities %>%
  mutate(volume = sapply(name, get_volume))

typeof(cities$volume)
world_map <- getMap(resolution = "high")

which(sapply(1:243, function(x) world_map@polygons[[x]]@ID) == "Switzerland")

switzerland <- world_map@polygons[[40]]@Polygons[[1]]@coords %>% as_tibble()



ggplot() +
geom_polygon(data = switzerland, aes(x=V1, y = V2), fill= NA, color = "black")+
geom_point( data= cities, aes(x=longitude, y=latitude, size=volume, color=language))+
scale_size_continuous(range=c(1,12)) +
coord_map()+
theme(panel.background = element_rect(fill= NA, colour="darkgrey",         linetype="solid"))+
xlab("longitude")+
ylab("latitude")+
labs(title = "Volume of real estate market in Switzerland",
    subtitle = "Updated on the")


```


## Problem 3: 3-D Random Walk

```{r}

#load libraries 
library(tidytext)
library(readxl)
library(tibble)
library(ggplot2)
library(dplyr)
library(plot3D)
library(animation)


##Question a

###OPTION 1, simpler without time column but somehow less elegant

#number of iterations
B <- 10^4
#set seed to have reproductible results
set.seed(1982)

#Create a list of length B of random nombers uniformely distributed between 0 and 1
Ut <- runif(B)

#Xtibble is the database of the vector X. The columns represent the the dimension we are moving on, namely x, y or z
Xtibble<- tibble( spaceX=0, spaceY=0, spaceZ=0)


tresholds<-c(1/6,2/6,3/6,4/6,5/6,6/6)

##Function that compares a number from Ut to the treshold to determine a direction to move on. 
ft<-function(u, a){
 { if(u<=a[1]){
    direction<- c(1,0,0)}else if(u>a[1]&& u<=a[2]) {
      direction<-c(-1,0,0)}else if (u>a[2]&& u<=a[3] ){
        direction<- c(0,1,0)}else if (u>a[3]&& u<=a[4] ){
          direction<- c(0,-1,0)}else if (u>a[4]&& u<=a[5] ){
            direction<- c(0,0,1)}else{
              direction<-c(0,0,-1)} }
 
  return(direction)
}
  
#for(i in 2:B){ 
 # for(j in 1:3){
  #  Xtibble[i,j]=Xtibble[i-1,j]+ft(Ut[i-1],tresholds)[j]}
#}

#

# For each iteration, we take the position at the iteration -1 and ad the new direction
for(i in 1:B+1){ 
     if(i==1){Xtibble[i]==c(0,0,0)}else{
       Xtibble[i,]=Xtibble[i-1,]+ft(Ut[i-1],tresholds)}
   }

#We get the final position at the iteration B: We need to use B+1 because we started with iteration 0
Xtibble[B+1,]

###OPTION 2,  time column 
B <- 10^4
set.seed(1982)

Ut <- runif(B)

#Same as before but with a column to show the iterations 
Xtibble<- tibble( spaceX=0, spaceY=0, spaceZ=0, iteration=0:B)

tresholds<-c(1/6,2/6,3/6,4/6,5/6,6/6)

ft<-function(u, a){
  { if(u<=a[1]){
    direction<- c(1,0,0)}else if(u>a[1]&& u<=a[2]) {
      direction<-c(-1,0,0)}else if (u>a[2]&& u<=a[3] ){
        direction<- c(0,1,0)}else if (u>a[3]&& u<=a[4] ){
          direction<- c(0,-1,0)}else if (u>a[4]&& u<=a[5] ){
            direction<- c(0,0,1)}else{
              direction<-c(0,0,-1)} }
  
  return(direction)
}

for(i in 1:B+1){ 
  for(j in 1:3){
  Xtibble[i,j]=Xtibble[i-1,j]+ft(Ut[i-1],tresholds)[j]}
}

print(Xtibble[Xtibble$iteration==B, ])

##Showing departure and arrival, 3D 
#Still needs title and beautifying :) 
pmat<-scatter3D(Xtibble$spaceX, Xtibble$spaceY, Xtibble$spaceZ,phi = 0, bty = "g", type = "b",
          ticktype = "detailed", pch = 10, 
          cex = c(0.1, 0.1, 0.1), col="black"
          )

points(trans3d(c(Xtibble$spaceX[1],Xtibble$spaceX[B+1]),
               c(Xtibble$spaceY[1],Xtibble$spaceY[B+1]),
               c(Xtibble$spaceZ[1],Xtibble$spaceZ[B+1]),
               pmat =pmat ),  col = c("green","red"), pch = 16)

##part B 
B <- 10^5
set.seed(2000)

Ut <- runif(B)

#Same as before but with a column to show the iterations 
Xtibble<- tibble( spaceX=0, spaceY=0, spaceZ=0, iteration=0:B)

tresholds<-c(1/6,2/6,3/6,4/6,5/6,6/6)
tresholds2<-0.99*tresholds

ft<-function(u, a){
  { if(u<=a[1]){
    direction<- c(1,0,0)}else if(u>a[1]&& u<=a[2]) {
      direction<-c(-1,0,0)}else if (u>a[2]&& u<=a[3] ){
        direction<- c(0,1,0)}else if (u>a[3]&& u<=a[4] ){
          direction<- c(0,-1,0)}else if (u>a[4]&& u<=a[5] ){
            direction<- c(0,0,1)}else{
              direction<-c(0,0,-1)} }
  
  return(direction)
}

for(i in 1:B+1){ 
  for(j in 1:3){
  Xtibble[i,j]=Xtibble[i-1,j]+ft(Ut[i-1],tresholds2)[j]}
}

print(Xtibble[Xtibble$iteration==B, ])

##Showing departure and arrival, 3D 
#Still needs title and beautifying :) 
pmat<-scatter3D(Xtibble$spaceX, Xtibble$spaceY, Xtibble$spaceZ,phi = 0, bty = "g", type = "b",
          ticktype = "detailed", pch = 10, 
          cex = c(0.1, 0.1, 0.1), col="black"
          )

points(trans3d(c(Xtibble$spaceX[1],Xtibble$spaceX[B+1]),
               c(Xtibble$spaceY[1],Xtibble$spaceY[B+1]),
               c(Xtibble$spaceZ[1],Xtibble$spaceZ[B+1]),
               pmat =pmat ),  col = c("green","red"), pch = 16)

##part B , works but so slooooow 
B <- 10^5
set.seed(2000)

Ut <- runif(B)

#Same as before but with a column to show the iterations 
Xtibble<- tibble( spaceX=0, spaceY=0, spaceZ=0, iteration=0:B)

tresholds<-c(1/6,2/6,3/6,4/6,5/6,6/6)
tresholds2<-0.99*tresholds

ft<-function(u, a){
  { if(u<=a[1]){
    direction<- c(1,0,0)}else if(u>a[1]&& u<=a[2]) {
      direction<-c(-1,0,0)}else if (u>a[2]&& u<=a[3] ){
        direction<- c(0,1,0)}else if (u>a[3]&& u<=a[4] ){
          direction<- c(0,-1,0)}else if (u>a[4]&& u<=a[5] ){
            direction<- c(0,0,1)}else{
              direction<-c(0,0,-1)} }
  
  return(direction)
}

#Try to see if quicker... not quicker... 
#ft2<-function(u, a){
#switch (u,
 #       "u<=a[1]" = direction<-c(1,0,0),
 #       "(u>a[1]&& u<=a[2])"=direction<-c(-1,0,0),
 #       "(u>a[2]&& u<=a[3])"=direction<-c(0,1,0),
 #       "(u>a[3]&& u<=a[4])"=direction<-c(0,-1,0),
 #       "(u>a[4]&& u<=a[5])"=direction<-c(0,0,1),
 #       "(u>a[5])"=direction<-c(-1,0,0)
#)
  
 # return(direction)
#}


for(i in 1:B+1){ 
  for(j in 1:3){
    Xtibble[i,j]=Xtibble[i-1,j]+ft(Ut[i-1],tresholds2)[j]}
}

print(Xtibble[Xtibble$iteration==B, ])

##Showing departure and arrival, 3D 
#Still needs title and beautifying :) 
pmat<-scatter3D(Xtibble$spaceX, Xtibble$spaceY, Xtibble$spaceZ,phi = 0, bty = "g", type = "b",
                ticktype = "detailed", pch = 10, 
                cex = c(0.1, 0.1, 0.1), col="black"
)

points(trans3d(c(Xtibble$spaceX[1],Xtibble$spaceX[B+1]),
               c(Xtibble$spaceY[1],Xtibble$spaceY[B+1]),
               c(Xtibble$spaceZ[1],Xtibble$spaceZ[B+1]),
               pmat =pmat ),  col = c("green","red"), pch = 16)


## Animation bonus:
brownian.motion(n = 20, xlim = c(-20, 20), ylim = c(-20, 20))

```


## Problem 4: Portfolio construction
```{r}

```
